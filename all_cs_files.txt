using Microsoft.EntityFrameworkCore;
using Microsoft.OpenApi.Models;
using YP_API.Data;
using YP_API.Interfaces;
using YP_API.Models;
using YP_API.Repositories;
using YP_API.Services;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader();
    });

    options.AddPolicy("AllowSpecificOrigins", policy =>
    {
        policy.WithOrigins("http://localhost:3000", "http://localhost:4200")
              .AllowAnyMethod()
              .AllowAnyHeader()
              .AllowCredentials();
    });
});

builder.Services.AddLogging(logging =>
{
    logging.AddConsole();
    logging.AddDebug();
    logging.SetMinimumLevel(LogLevel.Debug);
});

builder.Logging.ClearProviders();
builder.Logging.AddConsole();
builder.Logging.AddDebug();

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();

builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "Recipe Planner API",
        Version = "v1",
        Description = "API for managing recipes, menus and shopping lists"
    });

    c.CustomSchemaIds(x => x.FullName);
});

var connectionString = builder.Configuration.GetConnectionString("DefaultConnection")
    ?? "Server=localhost;Port=3306;Database=recipe_planner;Uid=root;Pwd=;";

builder.Services.AddDbContext<RecipePlannerContext>(options =>
{
    options.UseMySql(connectionString, ServerVersion.AutoDetect(connectionString));
    options.EnableSensitiveDataLogging();
    options.EnableDetailedErrors();
});
builder.Services.AddScoped<IRecipeRepository, RecipeRepository>();
builder.Services.AddScoped<IIngredientRepository, IngredientRepository>();
builder.Services.AddScoped<IMenuRepository, MenuRepository>();
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<IShoppingListRepository, ShoppingListRepository>();

builder.Services.AddScoped<IRepository<ShoppingList>, Repository<ShoppingList>>();
builder.Services.AddScoped<IRepository<ShoppingListItem>, Repository<ShoppingListItem>>();

builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<IMenuService, MenuService>();
builder.Services.AddScoped<IShoppingListService, ShoppingListService>();

builder.Services.AddScoped<IRepository<UserInventory>, Repository<UserInventory>>();

var app = builder.Build();

app.UseCors("AllowAll");

if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();

    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "Recipe Planner API v1");
        c.RoutePrefix = string.Empty;
        c.DocumentTitle = "Recipe Planner API Documentation";
    });
}
else
{
    app.UseExceptionHandler("/error");
    app.UseHsts();
}

app.Use(async (context, next) =>
{
    var logger = context.RequestServices.GetRequiredService<ILogger<Program>>();
    logger.LogInformation($"Request: {context.Request.Method} {context.Request.Path}");
    await next();
});

app.Use(async (context, next) =>
{
    try
    {
        await next();
    }
    catch (Exception ex)
    {
        var logger = context.RequestServices.GetRequiredService<ILogger<Program>>();
        logger.LogError(ex, "Unhandled exception: {Message}", ex.Message);

        logger.LogError("Stack trace: {StackTrace}", ex.StackTrace);

        context.Response.StatusCode = 500;
        await context.Response.WriteAsJsonAsync(new
        {
            error = "Internal server error",
            message = ex.Message,
            details = ex.StackTrace
        });
    }
});

app.MapControllers();

try
{
    using var scope = app.Services.CreateScope();
    var context = scope.ServiceProvider.GetRequiredService<RecipePlannerContext>();

    Console.WriteLine("Testing database connection...");
    var canConnect = await context.Database.CanConnectAsync();
    Console.WriteLine($"Database connected: {canConnect}");

    if (canConnect)
    {
        var userCount = await context.Users.CountAsync();
        Console.WriteLine($"Users in database: {userCount}");

        var recipeCount = await context.Recipes.CountAsync();
        Console.WriteLine($"Recipes in database: {recipeCount}");
    }
}
catch (Exception ex)
{
    Console.WriteLine($"Database check failed: {ex.Message}");
}

Console.WriteLine("Application started successfully");
Console.WriteLine($"Swagger available at: {app.Urls.FirstOrDefault()}");

app.Run();using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;
using YP_API.Models;

namespace YP_API.Configurations
{
    public class UserConfiguration : IEntityTypeConfiguration<User>
    {
        public void Configure(EntityTypeBuilder<User> builder)
        {
            builder.HasKey(u => u.Id);

            builder.Property(u => u.Username)
                .IsRequired()
                .HasMaxLength(50);

            builder.Property(u => u.Email)
                .IsRequired()
                .HasMaxLength(100);

            builder.Property(u => u.PasswordHash)
                .IsRequired();

            builder.Property(u => u.PasswordSalt)
                .IsRequired();

            builder.HasIndex(u => u.Username)
                .IsUnique();

            builder.HasIndex(u => u.Email)
                .IsUnique();
        }
    }
}

using Microsoft.AspNetCore.Mvc;
using System.ComponentModel.DataAnnotations;
using YP_API.Models;
using YP_API.Services;

namespace YP_API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly IAuthService _authService;

        public AuthController(IAuthService authService)
        {
            _authService = authService;
        }

        [HttpPost("register")]
        public async Task<ActionResult> Register(
            [FromForm]
            [Required(ErrorMessage = "Имя пользователя обязательно")]
            [StringLength(50, MinimumLength = 3, ErrorMessage = "Имя пользователя должно быть от 3 до 50 символов")]
            [Display(Name = "Имя пользователя")]
            string username,

            [FromForm]
            [Required(ErrorMessage = "Email обязателен")]
            [EmailAddress(ErrorMessage = "Неверный формат email")]
            [Display(Name = "Email адрес")]
            string email,

            [FromForm]
            [Required(ErrorMessage = "Полное имя обязательно")]
            [StringLength(100, ErrorMessage = "Полное имя не должно превышать 100 символов")]
            [Display(Name = "Полное имя")]
            string fullName,

            [FromForm]
            [Required(ErrorMessage = "Пароль обязателен")]
            [StringLength(100, MinimumLength = 6, ErrorMessage = "Пароль должен быть не менее 6 символов")]
            [Display(Name = "Пароль")]
            string password,

            [FromForm]
            [Display(Name = "Аллергии")]
            List<string> allergies = null)
        {
            try
            {
                var user = await _authService.Register(username, email, fullName, password, allergies ?? new List<string>());

                return Ok(new
                {
                    Id = user.Id,
                    Username = user.Username,
                    Email = user.Email,
                    FullName = user.FullName,
                    Message = "Пользователь успешно создан"
                });
            }
            catch (Exception ex)
            {
                return BadRequest(new { error = ex.Message });
            }
        }

        [HttpPost("login")]
        public async Task<ActionResult> Login(
            [FromForm]
            [Required(ErrorMessage = "Имя пользователя обязательно")]
            [Display(Name = "Имя пользователя")]
            string username,

            [FromForm]
            [Required(ErrorMessage = "Пароль обязателен")]
            [Display(Name = "Пароль")]
            string password)
        {
            try
            {
                var user = await _authService.Login(username, password);

                return Ok(new
                {
                    Id = user.Id,
                    Username = user.Username,
                    Email = user.Email,
                    FullName = user.FullName,
                    Message = "Пользователь успешно найден"
                });
            }
            catch (Exception ex)
            {
                return Unauthorized(new { error = ex.Message });
            }
        }
    }
}using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

namespace YP_API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class BaseApiController : ControllerBase
    {
        protected int GetUserId()
        {
            try
            {
                var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value
                               ?? User.FindFirst("nameid")?.Value
                               ?? User.FindFirst("sub")?.Value
                               ?? User.FindFirst("userId")?.Value;

                if (string.IsNullOrEmpty(userIdClaim))
                {
                    var allClaims = User.Claims.Select(c => $"{c.Type}: {c.Value}").ToList();
                    Console.WriteLine("Available claims: " + string.Join(", ", allClaims));

                    throw new UnauthorizedAccessException("User ID not found in token. Available claims: " + string.Join(", ", allClaims));
                }

                if (int.TryParse(userIdClaim, out int userId))
                {
                    return userId;
                }

                throw new UnauthorizedAccessException($"Invalid user ID format in token: {userIdClaim}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in GetUserId: {ex.Message}");
                throw;
            }
        }
    }
}п»їusing Microsoft.AspNetCore.Mvc;
using System.ComponentModel.DataAnnotations;
using YP_API.Interfaces;
using YP_API.Models;

namespace YP_API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class InventoryController : ControllerBase
    {
        private readonly IUserRepository _userRepository;
        private readonly IIngredientRepository _ingredientRepository;
        private readonly IRepository<UserInventory> _inventoryRepository;
        private readonly ILogger<InventoryController> _logger;

        public InventoryController(
            IUserRepository userRepository,
            IIngredientRepository ingredientRepository,
            IRepository<UserInventory> inventoryRepository,
            ILogger<InventoryController> logger)
        {
            _userRepository = userRepository;
            _ingredientRepository = ingredientRepository;
            _inventoryRepository = inventoryRepository;
            _logger = logger;
        }

        [HttpGet("{userId}")]
        public async Task<ActionResult> GetInventory(int userId)
        {
            try
            {
                var user = await _userRepository.GetByIdAsync(userId);
                if (user == null)
                {
                    return NotFound(new
                    {
                        success = false,
                        error = "РџРѕР»СЊР·РѕРІР°С‚РµР»СЊ РЅРµ РЅР°Р№РґРµРЅ",
                        message = $"РџРѕР»СЊР·РѕРІР°С‚РµР»СЊ СЃ ID {userId} РЅРµ СЃСѓС‰РµСЃС‚РІСѓРµС‚"
                    });
                }

                var inventory = await _inventoryRepository.GetAllAsync();
                var userInventory = inventory.OfType<UserInventory>()
                    .Where(ui => ui.UserId == userId)
                    .ToList();

                return Ok(new
                {
                    success = true,
                    message = "РРЅРІРµРЅС‚Р°СЂСЊ РїРѕР»СѓС‡РµРЅ СѓСЃРїРµС€РЅРѕ",
                    data = userInventory.Select(ui => new
                    {
                        Id = ui.Id,
                        ProductName = ui.Ingredient?.Name,
                        IngredientId = ui.IngredientId,
                        Quantity = ui.Quantity,
                        Unit = ui.Unit,
                        ExpiryDate = ui.ExpiryDate,
                        AddedAt = ui.AddedAt
                    })
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in GetInventory: {ex.Message}");
                return StatusCode(500, new
                {
                    success = false,
                    error = "Р’РЅСѓС‚СЂРµРЅРЅСЏСЏ РѕС€РёР±РєР° СЃРµСЂРІРµСЂР°",
                    message = "РћС€РёР±РєР° РїСЂРё РїРѕР»СѓС‡РµРЅРёРё РёРЅРІРµРЅС‚Р°СЂСЏ"
                });
            }
        }

        [HttpPost("add/{userId}")]
        public async Task<ActionResult> AddToInventory(
            int userId,
            [FromForm]
            [Required(ErrorMessage = "РќР°Р·РІР°РЅРёРµ РїСЂРѕРґСѓРєС‚Р° РѕР±СЏР·Р°С‚РµР»СЊРЅРѕ")]
            [Display(Name = "РќР°Р·РІР°РЅРёРµ РїСЂРѕРґСѓРєС‚Р°")]
            string productName,

            [FromForm]
            [Range(0.001, 1000, ErrorMessage = "РљРѕР»РёС‡РµСЃС‚РІРѕ РґРѕР»Р¶РЅРѕ Р±С‹С‚СЊ РѕС‚ 0.001 РґРѕ 1000")]
            [Display(Name = "РљРѕР»РёС‡РµСЃС‚РІРѕ")]
            decimal quantity = 1,

            [FromForm]
            [Display(Name = "Р•РґРёРЅРёС†Р° РёР·РјРµСЂРµРЅРёСЏ")]
            string unit = "С€С‚")
        {
            try
            {
                var user = await _userRepository.GetByIdAsync(userId);
                if (user == null)
                {
                    return BadRequest(new
                    {
                        success = false,
                        error = "РџРѕР»СЊР·РѕРІР°С‚РµР»СЊ РЅРµ РЅР°Р№РґРµРЅ",
                        message = "РќРµ СѓРґР°Р»РѕСЃСЊ РЅР°Р№С‚Рё СѓРєР°Р·Р°РЅРЅРѕРіРѕ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ"
                    });
                }

                var ingredient = await _ingredientRepository.GetIngredientByNameAsync(productName);
                if (ingredient == null)
                {
                    ingredient = new Ingredient
                    {
                        Name = productName,
                        Category = "Р”СЂСѓРіРѕРµ",
                        StandardUnit = unit
                    };
                    await _ingredientRepository.AddAsync(ingredient);
                    await _ingredientRepository.SaveAllAsync();
                }

                var existingInventory = (await _inventoryRepository.GetAllAsync())
                    .OfType<UserInventory>()
                    .FirstOrDefault(ui => ui.UserId == userId && ui.IngredientId == ingredient.Id);

                if (existingInventory != null)
                {
                    existingInventory.Quantity += quantity;
                    _inventoryRepository.Update(existingInventory);
                }
                else
                {
                    // РЎРѕР·РґР°РµРј РЅРѕРІСѓСЋ Р·Р°РїРёСЃСЊ
                    var inventoryItem = new UserInventory
                    {
                        UserId = userId,
                        IngredientId = ingredient.Id,
                        Quantity = quantity,
                        Unit = unit,
                        AddedAt = DateTime.UtcNow
                    };
                    await _inventoryRepository.AddAsync(inventoryItem);
                }

                if (await _inventoryRepository.SaveAllAsync())
                {
                    return Ok(new
                    {
                        success = true,
                        message = "РџСЂРѕРґСѓРєС‚ СѓСЃРїРµС€РЅРѕ РґРѕР±Р°РІР»РµРЅ РІ РёРЅРІРµРЅС‚Р°СЂСЊ",
                        data = new
                        {
                            ProductName = ingredient.Name,
                            Quantity = quantity,
                            Unit = unit
                        }
                    });
                }

                return BadRequest(new
                {
                    success = false,
                    error = "РћС€РёР±РєР° СЃРѕС…СЂР°РЅРµРЅРёСЏ",
                    message = "РќРµ СѓРґР°Р»РѕСЃСЊ СЃРѕС…СЂР°РЅРёС‚СЊ РїСЂРѕРґСѓРєС‚ РІ РёРЅРІРµРЅС‚Р°СЂСЊ"
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in AddToInventory: {ex.Message}");
                return BadRequest(new
                {
                    success = false,
                    error = "РћС€РёР±РєР° РґРѕР±Р°РІР»РµРЅРёСЏ РІ РёРЅРІРµРЅС‚Р°СЂСЊ",
                    message = ex.Message
                });
            }
        }

        [HttpDelete("{userId}/items/{itemId}")]
        public async Task<ActionResult> RemoveFromInventory(int userId, int itemId)
        {
            try
            {
                var inventoryItem = await _inventoryRepository.GetByIdAsync(itemId) as UserInventory;
                if (inventoryItem == null || inventoryItem.UserId != userId)
                {
                    return NotFound(new
                    {
                        success = false,
                        error = "Р­Р»РµРјРµРЅС‚ РЅРµ РЅР°Р№РґРµРЅ",
                        message = "Р­Р»РµРјРµРЅС‚ РёРЅРІРµРЅС‚Р°СЂСЏ РЅРµ РЅР°Р№РґРµРЅ РёР»Рё РЅРµ РїСЂРёРЅР°РґР»РµР¶РёС‚ РїРѕР»СЊР·РѕРІР°С‚РµР»СЋ"
                    });
                }

                _inventoryRepository.Delete(inventoryItem);

                if (await _inventoryRepository.SaveAllAsync())
                {
                    return Ok(new
                    {
                        success = true,
                        message = "РџСЂРѕРґСѓРєС‚ СѓСЃРїРµС€РЅРѕ СѓРґР°Р»РµРЅ РёР· РёРЅРІРµРЅС‚Р°СЂСЏ"
                    });
                }

                return BadRequest(new
                {
                    success = false,
                    error = "РћС€РёР±РєР° СѓРґР°Р»РµРЅРёСЏ",
                    message = "РќРµ СѓРґР°Р»РѕСЃСЊ СѓРґР°Р»РёС‚СЊ РїСЂРѕРґСѓРєС‚ РёР· РёРЅРІРµРЅС‚Р°СЂСЏ"
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in RemoveFromInventory: {ex.Message}");
                return BadRequest(new
                {
                    success = false,
                    error = "РћС€РёР±РєР° СѓРґР°Р»РµРЅРёСЏ РёР· РёРЅРІРµРЅС‚Р°СЂСЏ",
                    message = ex.Message
                });
            }
        }

        [HttpPut("{userId}/items/{itemId}")]
        public async Task<ActionResult> UpdateInventoryItem(
            int userId,
            int itemId,
            [FromForm]
            [Range(0.001, 1000, ErrorMessage = "РљРѕР»РёС‡РµСЃС‚РІРѕ РґРѕР»Р¶РЅРѕ Р±С‹С‚СЊ РѕС‚ 0.001 РґРѕ 1000")]
            [Display(Name = "РљРѕР»РёС‡РµСЃС‚РІРѕ")]
            decimal quantity,

            [FromForm]
            [Display(Name = "Р•РґРёРЅРёС†Р° РёР·РјРµСЂРµРЅРёСЏ")]
            string unit = "С€С‚")
        {
            try
            {
                var inventoryItem = await _inventoryRepository.GetByIdAsync(itemId) as UserInventory;
                if (inventoryItem == null || inventoryItem.UserId != userId)
                {
                    return NotFound(new
                    {
                        success = false,
                        error = "Р­Р»РµРјРµРЅС‚ РЅРµ РЅР°Р№РґРµРЅ",
                        message = "Р­Р»РµРјРµРЅС‚ РёРЅРІРµРЅС‚Р°СЂСЏ РЅРµ РЅР°Р№РґРµРЅ РёР»Рё РЅРµ РїСЂРёРЅР°РґР»РµР¶РёС‚ РїРѕР»СЊР·РѕРІР°С‚РµР»СЋ"
                    });
                }

                inventoryItem.Quantity = quantity;
                inventoryItem.Unit = unit;

                _inventoryRepository.Update(inventoryItem);

                if (await _inventoryRepository.SaveAllAsync())
                {
                    return Ok(new
                    {
                        success = true,
                        message = "РџСЂРѕРґСѓРєС‚ СѓСЃРїРµС€РЅРѕ РѕР±РЅРѕРІР»РµРЅ",
                        data = new
                        {
                            Id = inventoryItem.Id,
                            Quantity = inventoryItem.Quantity,
                            Unit = inventoryItem.Unit
                        }
                    });
                }

                return BadRequest(new
                {
                    success = false,
                    error = "РћС€РёР±РєР° РѕР±РЅРѕРІР»РµРЅРёСЏ",
                    message = "РќРµ СѓРґР°Р»РѕСЃСЊ РѕР±РЅРѕРІРёС‚СЊ РїСЂРѕРґСѓРєС‚ РІ РёРЅРІРµРЅС‚Р°СЂРµ"
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in UpdateInventoryItem: {ex.Message}");
                return BadRequest(new
                {
                    success = false,
                    error = "РћС€РёР±РєР° РѕР±РЅРѕРІР»РµРЅРёСЏ РёРЅРІРµРЅС‚Р°СЂСЏ",
                    message = ex.Message
                });
            }
        }
    }
}using Microsoft.AspNetCore.Mvc;
using System.ComponentModel.DataAnnotations;
using YP_API.Interfaces;
using YP_API.Models;
using YP_API.Services;

namespace YP_API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class MenuController : ControllerBase
    {
        private readonly IMenuService _menuService;
        private readonly IUserRepository _userRepository;
        private readonly IRecipeRepository _recipeRepository;
        private readonly ILogger<MenuController> _logger;

        public MenuController(IMenuService menuService, IUserRepository userRepository, IRecipeRepository recipeRepository, ILogger<MenuController> logger)
        {
            _menuService = menuService;
            _userRepository = userRepository;
            _recipeRepository = recipeRepository;
            _logger = logger;
        }

        [HttpGet("current/{userId}")]
        public async Task<ActionResult> GetCurrentMenu(int userId)
        {
            try
            {
                _logger.LogInformation($"Getting current menu for user ID: {userId}");

                var menu = await _menuService.GetCurrentMenuAsync(userId);

                if (menu == null)
                    return Ok(new
                    {
                        success = false,
                        message = "Текущее меню не найдено",
                        data = (object)null
                    });

                return Ok(new
                {
                    success = true,
                    message = "Меню найдено",
                    data = new
                    {
                        Id = menu.Id,
                        Name = menu.Name,
                        StartDate = menu.StartDate,
                        EndDate = menu.EndDate,
                        TotalCalories = menu.TotalCalories,
                        Days = menu.MenuMeals?.GroupBy(m => m.MealDate).Select(g => new {
                            Date = g.Key,
                            Meals = g.Select(m => new {
                                Id = m.Id,
                                RecipeId = m.RecipeId,
                                RecipeTitle = m.Recipe?.Title,
                                MealType = m.MealType,
                                Calories = m.Recipe?.Calories,
                                PrepTime = (m.Recipe?.PrepTime ?? 0) + (m.Recipe?.CookTime ?? 0),
                                ImageUrl = m.Recipe?.ImageUrl
                            })
                        })
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in GetCurrentMenu: {ex.Message}");
                return StatusCode(500, new
                {
                    success = false,
                    error = "Внутренняя ошибка сервера",
                    message = "Произошла ошибка при получении меню"
                });
            }
        }

        [HttpPost("generate/{userId}")]
        public async Task<ActionResult> GenerateMenu(
            int userId,
            [FromForm]
            [Range(1, 30, ErrorMessage = "Количество дней должно быть от 1 до 30")]
            [Display(Name = "Количество дней")]
            int days = 7,

            [FromForm]
            [Range(0, 10000, ErrorMessage = "Калории должны быть от 0 до 10000")]
            [Display(Name = "Желаемые калории в день")]
            decimal? targetCaloriesPerDay = null,

            [FromForm]
            [Display(Name = "Тип кухни")]
            List<string> cuisineTags = null,

            [FromForm]
            [Display(Name = "Типы приемов пищи")]
            List<string> mealTypes = null,

            [FromForm]
            [Display(Name = "Использовать инвентарь")]
            bool useInventory = false)
        {
            try
            {
                _logger.LogInformation($"Generating menu for user {userId}, days: {days}, calories: {targetCaloriesPerDay}");

                var user = await _userRepository.GetByIdAsync(userId);
                if (user == null)
                {
                    return BadRequest(new
                    {
                        success = false,
                        error = "Пользователь не найден",
                        message = "Не удалось найти данного пользователя"
                    });
                }

                var availableRecipes = await _recipeRepository.GetRecipesForMenuAsync(
                    user.Allergies ?? new List<string>(),
                    cuisineTags ?? new List<string>(),
                    targetCaloriesPerDay);

                if (!availableRecipes.Any())
                {
                    _logger.LogWarning($"No recipes available for user {userId} with filters: allergies={user.Allergies?.Count}, cuisineTags={cuisineTags?.Count}, maxCalories={targetCaloriesPerDay}");

                    return BadRequest(new
                    {
                        success = false,
                        error = "Нет доступных рецептов",
                        message = "Не найдено рецептов по заданным фильтрам. Попробуйте изменить фильтры.",
                        suggestions = new
                        {
                            tryWithoutAllergies = user.Allergies?.Any() == true,
                            tryWithoutCuisineTags = cuisineTags?.Any() == true,
                            tryHigherCalories = targetCaloriesPerDay.HasValue
                        }
                    });
                }

                var request = new GenerateMenuRequest
                {
                    Days = days,
                    TargetCaloriesPerDay = targetCaloriesPerDay,
                    CuisineTags = cuisineTags ?? new List<string>(),
                    MealTypes = mealTypes ?? new List<string> { "breakfast", "lunch", "dinner" },
                    UseInventory = useInventory
                };

                var menu = await _menuService.GenerateWeeklyMenuAsync(userId, request, user.Allergies);

                _logger.LogInformation($"Menu generated successfully: {menu.Id} with {menu.MenuMeals?.Count} meals");

                return Ok(new
                {
                    success = true,
                    message = "Меню успешно сгенерировано",
                    data = new
                    {
                        Id = menu.Id,
                        Name = menu.Name,
                        StartDate = menu.StartDate,
                        EndDate = menu.EndDate,
                        TotalCalories = menu.TotalCalories,
                        MealCount = menu.MenuMeals?.Count ?? 0
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in GenerateMenu: {ex.Message}");
                return BadRequest(new
                {
                    success = false,
                    error = "Ошибка генерации меню",
                    message = ex.Message
                });
            }
        }

        [HttpGet("history/{userId}")]
        public async Task<ActionResult> GetMenuHistory(int userId)
        {
            try
            {
                var menus = await _menuService.GetUserMenuHistoryAsync(userId);

                if (!menus.Any())
                {
                    return Ok(new
                    {
                        success = true,
                        message = "История меню пуста",
                        data = new List<object>()
                    });
                }

                return Ok(new
                {
                    success = true,
                    message = "История меню получена",
                    data = menus.Select(m => new {
                        Id = m.Id,
                        Name = m.Name,
                        StartDate = m.StartDate,
                        EndDate = m.EndDate,
                        TotalCalories = m.TotalCalories,
                        CreatedAt = m.CreatedAt
                    })
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in GetMenuHistory: {ex.Message}");
                return StatusCode(500, new
                {
                    success = false,
                    error = "Внутренняя ошибка сервера",
                    message = "Произошла ошибка при получении истории"
                });
            }
        }

        [HttpPost("{menuId}/regenerate-day")]
        public async Task<ActionResult> RegenerateDay(
            int menuId,
            [FromForm]
            [Required(ErrorMessage = "Дата обязательна")]
            [Display(Name = "Дата для перегенерации")]
            DateTime date)
        {
            try
            {
                var menu = await _menuService.RegenerateDayAsync(menuId, date, null);

                return Ok(new
                {
                    success = true,
                    message = "День успешно перегенерирован",
                    data = new
                    {
                        MenuId = menu.Id,
                        Date = date
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in RegenerateDay: {ex.Message}");
                return BadRequest(new
                {
                    success = false,
                    error = "Ошибка перегенерации",
                    message = ex.Message
                });
            }
        }
    }

    public class GenerateMenuRequest
    {
        public int Days { get; set; } = 7;
        public decimal? TargetCaloriesPerDay { get; set; }
        public List<string> CuisineTags { get; set; } = new List<string>();
        public List<string> MealTypes { get; set; } = new List<string> { "breakfast", "lunch", "dinner" };
        public bool UseInventory { get; set; } = false;
    }
}using Microsoft.AspNetCore.Mvc;
using System.ComponentModel.DataAnnotations;
using YP_API.Helpers;
using YP_API.Interfaces;
using YP_API.Models;

namespace YP_API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class RecipesController : ControllerBase
    {
        private readonly IRecipeRepository _recipeRepository;
        private readonly ILogger<RecipesController> _logger;

        public RecipesController(IRecipeRepository recipeRepository, ILogger<RecipesController> logger)
        {
            _recipeRepository = recipeRepository;
            _logger = logger;
        }

        [HttpGet]
        public async Task<ActionResult> GetRecipes([FromQuery] RecipeSearchParams searchParams)
        {
            try
            {
                var recipes = await _recipeRepository.GetRecipesAsync(searchParams);

                Response.Headers.Add("X-Pagination", System.Text.Json.JsonSerializer.Serialize(new
                {
                    recipes.CurrentPage,
                    recipes.PageSize,
                    recipes.TotalCount,
                    recipes.TotalPages
                }));

                return Ok(new
                {
                    success = true,
                    message = "Рецепты получены успешно",
                    data = recipes.Select(r => new {
                        Id = r.Id,
                        Title = r.Title,
                        Description = r.Description,
                        PrepTime = r.PrepTime,
                        CookTime = r.CookTime,
                        Calories = r.Calories,
                        ImageUrl = r.ImageUrl,
                        Difficulty = r.Difficulty
                    })
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in GetRecipes: {ex.Message}");
                return StatusCode(500, new
                {
                    success = false,
                    error = "Внутренняя ошибка сервера",
                    message = "Произошла ошибка при получении рецептов"
                });
            }
        }

        [HttpGet("{id}")]
        public async Task<ActionResult> GetRecipe(int id)
        {
            try
            {
                var recipe = await _recipeRepository.GetRecipeWithDetailsAsync(id);

                if (recipe == null)
                    return NotFound(new
                    {
                        success = false,
                        error = "Рецепт не найден",
                        message = $"Рецепт с ID {id} не существует"
                    });

                return Ok(new
                {
                    success = true,
                    message = "Рецепт получен успешно",
                    data = new
                    {
                        Id = recipe.Id,
                        Title = recipe.Title,
                        Description = recipe.Description,
                        Instructions = recipe.Instructions,
                        PrepTime = recipe.PrepTime,
                        CookTime = recipe.CookTime,
                        Servings = recipe.Servings,
                        Calories = recipe.Calories,
                        ImageUrl = recipe.ImageUrl,
                        Difficulty = recipe.Difficulty,
                        CuisineType = recipe.CuisineType,
                        Ingredients = recipe.RecipeIngredients?.Select(ri => new {
                            Name = ri.Ingredient?.Name,
                            Quantity = ri.Quantity,
                            Unit = ri.Unit,
                            Category = ri.Ingredient?.Category
                        })
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in GetRecipe: {ex.Message}");
                return StatusCode(500, new
                {
                    success = false,
                    error = "Внутренняя ошибка сервера",
                    message = "Произошла ошибка при получении рецепта"
                });
            }
        }

        [HttpPost]
        public async Task<ActionResult> CreateRecipe(
            [FromForm]
            [Required(ErrorMessage = "Название рецепта обязательно")]
            [Display(Name = "Название рецепта")]
            string title,

            [FromForm]
            [Display(Name = "Описание рецепта")]
            string description,

            [FromForm]
            [Required(ErrorMessage = "Инструкции обязательны")]
            [Display(Name = "Инструкции приготовления")]
            string instructions,

            [FromForm]
            [Range(0, 1000, ErrorMessage = "Время подготовки должно быть от 0 до 1000 минут")]
            [Display(Name = "Время подготовки (минуты)")]
            int prepTime,

            [FromForm]
            [Range(0, 1000, ErrorMessage = "Время готовки должно быть от 0 до 1000 минут")]
            [Display(Name = "Время готовки (минуты)")]
            int cookTime,

            [FromForm]
            [Range(1, 100, ErrorMessage = "Количество порций должно быть от 1 до 100")]
            [Display(Name = "Количество порций")]
            int servings,

            [FromForm]
            [Range(0, 10000, ErrorMessage = "Калории должны быть от 0 до 10000")]
            [Display(Name = "Калории")]
            decimal calories,

            [FromForm]
            [Url(ErrorMessage = "Неверный URL изображения")]
            [Display(Name = "URL изображения")]
            string imageUrl = "",

            [FromForm]
            [Display(Name = "Тип кухни")]
            string cuisineType = "",

            [FromForm]
            [Display(Name = "Сложность приготовления")]
            string difficulty = "")
        {
            try
            {
                var recipe = new Recipe
                {
                    Title = title,
                    Description = description,
                    Instructions = instructions,
                    PrepTime = prepTime,
                    CookTime = cookTime,
                    Servings = servings,
                    Calories = calories,
                    ImageUrl = imageUrl,
                    CuisineType = cuisineType,
                    Difficulty = difficulty,
                    CreatedAt = DateTime.UtcNow
                };

                await _recipeRepository.AddAsync(recipe);

                if (await _recipeRepository.SaveAllAsync())
                {
                    return Ok(new
                    {
                        success = true,
                        message = "Рецепт успешно создан",
                        data = new
                        {
                            Id = recipe.Id,
                            Title = recipe.Title
                        }
                    });
                }

                return BadRequest(new
                {
                    success = false,
                    error = "Ошибка создания рецепта",
                    message = "Не удалось сохранить рецепт в базе данных"
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in CreateRecipe: {ex.Message}");
                return BadRequest(new
                {
                    success = false,
                    error = "Ошибка создания рецепта",
                    message = ex.Message
                });
            }
        }

        [HttpPost("{id}/favorite/{userId}")]
        public async Task<ActionResult> ToggleFavorite(int id, int userId)
        {
            try
            {
                _logger.LogInformation($"Toggling favorite for user {userId}, recipe {id}");

                var success = await _recipeRepository.ToggleFavoriteAsync(userId, id);

                if (success)
                {
                    var isFavorite = await _recipeRepository.IsRecipeFavoriteAsync(userId, id);

                    return Ok(new
                    {
                        success = true,
                        message = isFavorite ? "Рецепт добавлен в избранное" : "Рецепт удален из избранного",
                        data = new
                        {
                            RecipeId = id,
                            IsFavorite = isFavorite
                        }
                    });
                }

                return BadRequest(new
                {
                    success = false,
                    error = "Ошибка изменения избранного",
                    message = "Не удалось изменить статус избранного"
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in ToggleFavorite: {ex.Message}");
                _logger.LogError($"Stack trace: {ex.StackTrace}");

                return BadRequest(new
                {
                    success = false,
                    error = "Ошибка изменения избранного",
                    message = ex.Message
                });
            }
        }

        [HttpGet("favorites/{userId}")]
        public async Task<ActionResult> GetFavorites(int userId)
        {
            try
            {
                var favorites = await _recipeRepository.GetUserFavoritesAsync(userId);

                return Ok(new
                {
                    success = true,
                    message = "Избранные рецепты получены",
                    data = favorites.Select(r => new {
                        Id = r.Id,
                        Title = r.Title,
                        Description = r.Description,
                        Calories = r.Calories,
                        ImageUrl = r.ImageUrl,
                        PrepTime = r.PrepTime,
                        CookTime = r.CookTime
                    })
                });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error in GetFavorites: {ex.Message}");
                return StatusCode(500, new
                {
                    success = false,
                    error = "Внутренняя ошибка сервера",
                    message = "Произошла ошибка при получении избранных рецептов"
                });
            }
        }
    }

    public class CreateRecipeIngredientRequest
    {
        public int IngredientId { get; set; }
        public decimal Quantity { get; set; }
        public string Unit { get; set; }
    }
}using Microsoft.AspNetCore.Mvc;
using System.ComponentModel.DataAnnotations;
using YP_API.Interfaces;
using YP_API.Models;
using YP_API.Services;

namespace YP_API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class ShoppingListController : ControllerBase
    {
        private readonly IShoppingListService _shoppingListService;

        public ShoppingListController(IShoppingListService shoppingListService)
        {
            _shoppingListService = shoppingListService;
        }

        [HttpGet("current/{userId}")]
        public async Task<ActionResult> GetCurrentShoppingList(int userId)
        {
            var shoppingList = await _shoppingListService.GetCurrentShoppingListAsync(userId);

            if (shoppingList == null)
                return NotFound(new { error = "Текущий список покупок не найден" });

            return Ok(new
            {
                Id = shoppingList.Id,
                Name = shoppingList.Name,
                IsCompleted = shoppingList.IsCompleted,
                Items = shoppingList.Items?.Select(i => new {
                    Id = i.Id,
                    IngredientName = i.Ingredient?.Name,
                    Quantity = i.Quantity,
                    Unit = i.Unit,
                    Category = i.Category,
                    IsPurchased = i.IsPurchased
                })
            });
        }

        [HttpPost("{listId}/items/{itemId}/toggle")]
        public async Task<ActionResult> ToggleItemPurchased(
            int listId,
            int itemId,
            [FromForm]
            [Required(ErrorMessage = "Статус покупки обязателен")]
            [Display(Name = "Статус покупки (куплено/не куплено)")]
            bool isPurchased)
        {
            var success = await _shoppingListService.ToggleItemPurchasedAsync(itemId, isPurchased);

            if (success)
                return Ok(new { message = "Статус покупки успешно изменен" });

            return BadRequest(new { error = "Не удалось изменить статус покупки" });
        }

        [HttpPost("generate-from-menu/{menuId}/{userId}")]
        public async Task<ActionResult> GenerateFromMenu(int menuId, int userId)
        {
            try
            {
                var shoppingList = await _shoppingListService.GenerateShoppingListFromMenuAsync(menuId, userId);

                return Ok(new
                {
                    Id = shoppingList.Id,
                    Name = shoppingList.Name,
                    Message = "Список покупок успешно сгенерирован",
                    ItemsCount = shoppingList.Items?.Count ?? 0
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in GenerateFromMenu: {ex.Message}");
                if (ex.InnerException != null)
                {
                    Console.WriteLine($"Inner exception: {ex.InnerException.Message}");
                }

                return BadRequest(new
                {
                    success = false,
                    error = "Ошибка генерации списка покупок",
                    message = ex.Message,
                    details = ex.InnerException?.Message
                });
            }
        }
    }
}п»їusing Microsoft.AspNetCore.Mvc;
using YP_API.Interfaces;
using YP_API.Models.Dtos;

[ApiController]
[Route("api/[controller]")]
public class UserController : ControllerBase
{
    private readonly IUserRepository _userRepository;
    private readonly ILogger<UserController> _logger;

    public UserController(IUserRepository userRepository, ILogger<UserController> logger)
    {
        _userRepository = userRepository;
        _logger = logger;
    }

    [HttpGet("profile/{userId}")]
    public async Task<ActionResult> GetUserProfile(int userId)
    {
        try
        {
            var user = await _userRepository.GetByIdAsync(userId);

            if (user == null)
            {
                return NotFound(new { success = false, error = "User not found" });
            }

            var userProfile = new
            {
                Username = user.Username,
                Email = user.Email,
                FullName = user.FullName,
                CreatedAt = user.CreatedAt,
                Allergies = user.Allergies ?? new List<string>()
            };

            return Ok(userProfile);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting user profile");
            return StatusCode(500, new { success = false, error = ex.Message });
        }
    }

    [HttpPost("profile/{userId}")]
    public async Task<ActionResult> UpdateUserProfile(
        int userId,
        [FromForm] string fullName,
        [FromForm] string email)
    {
        try
        {
            var user = await _userRepository.GetByIdAsync(userId);

            if (user == null)
            {
                return NotFound(new { success = false, error = "User not found" });
            }

            user.FullName = fullName;
            user.Email = email;

            _userRepository.Update(user);
            if (await _userRepository.SaveAllAsync())
            {
                return Ok(new { success = true, message = "Profile updated" });
            }
            return BadRequest(new { success = false, error = "Failed to update profile" });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating user profile");
            return StatusCode(500, new { success = false, error = ex.Message });
        }
    }

    [HttpGet("allergies/{userId}")]
    public async Task<ActionResult<List<string>>> GetUserAllergies(int userId)
    {
        try
        {
            var user = await _userRepository.GetByIdAsync(userId);

            if (user == null)
            {
                return NotFound(new { success = false, error = "User not found" });
            }

            return Ok(user.Allergies ?? new List<string>());
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting user allergies");
            return StatusCode(500, new { success = false, error = ex.Message });
        }
    }

    [HttpPost("allergies/{userId}")]
    public async Task<ActionResult> UpdateUserAllergies(
        int userId,
        [FromBody] UpdateAllergiesDto updateDto)
    {
        try
        {
            var user = await _userRepository.GetByIdAsync(userId);

            if (user == null)
            {
                return NotFound(new { success = false, error = "User not found" });
            }

            user.Allergies = updateDto.Allergies ?? new List<string>();

            _userRepository.Update(user);
            if (await _userRepository.SaveAllAsync())
            {
                return Ok(new { success = true, message = "Allergies updated" });
            }
            return BadRequest(new { success = false, error = "Failed to update allergies" });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating user allergies");
            return StatusCode(500, new { success = false, error = ex.Message });
        }
    }
}using Microsoft.EntityFrameworkCore;
using YP_API.Configurations;
using YP_API.Models;

namespace YP_API.Data
{
    public class RecipePlannerContext : DbContext
    {
        public RecipePlannerContext(DbContextOptions<RecipePlannerContext> options) : base(options) { }

        public DbSet<User> Users { get; set; }
        public DbSet<Recipe> Recipes { get; set; }
        public DbSet<Ingredient> Ingredients { get; set; }
        public DbSet<WeeklyMenu> WeeklyMenus { get; set; }
        public DbSet<MenuMeal> MenuMeals { get; set; }
        public DbSet<ShoppingList> ShoppingLists { get; set; }
        public DbSet<ShoppingListItem> ShoppingListItems { get; set; }
        public DbSet<UserFavorite> UserFavorites { get; set; }
        public DbSet<UserInventory> UserInventories { get; set; }
        public DbSet<RecipeIngredient> RecipeIngredients { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<User>(entity =>
            {
                entity.HasKey(u => u.Id);
                entity.Property(u => u.Username).IsRequired().HasMaxLength(50);
                entity.Property(u => u.Email).IsRequired().HasMaxLength(100);
                entity.Property(u => u.FullName).IsRequired().HasMaxLength(100);
                entity.Property(u => u.Allergies)
                    .HasConversion(
                        v => string.Join(',', v),
                        v => v.Split(',', StringSplitOptions.RemoveEmptyEntries).ToList()
                    );
                entity.HasIndex(u => u.Username).IsUnique();
                entity.HasIndex(u => u.Email).IsUnique();
            });

            modelBuilder.Entity<Recipe>(entity =>
            {
                entity.HasKey(r => r.Id);
                entity.Property(r => r.Title).IsRequired().HasMaxLength(200);
                entity.Property(r => r.Description).HasMaxLength(1000).HasDefaultValue("");
                entity.Property(r => r.Instructions).HasColumnType("text").HasDefaultValue("");
                entity.Property(r => r.ImageUrl).HasMaxLength(500).HasDefaultValue("");
                entity.Property(r => r.Calories).HasPrecision(10, 2);
                entity.Property(r => r.CuisineType).HasMaxLength(50).HasDefaultValue("");
                entity.Property(r => r.Difficulty).HasMaxLength(20).HasDefaultValue("");

                entity.Property(r => r.Tags)
                    .HasConversion(
                        v => string.Join(',', v),
                        v => v.Split(',', StringSplitOptions.RemoveEmptyEntries).ToList()
                    );

                entity.Property(r => r.Allergens)
                    .HasConversion(
                        v => string.Join(',', v),
                        v => v.Split(',', StringSplitOptions.RemoveEmptyEntries).ToList()
                    );
            });

            modelBuilder.Entity<Ingredient>(entity =>
            {
                entity.HasKey(i => i.Id);
                entity.Property(i => i.Name).IsRequired().HasMaxLength(100);
                entity.Property(i => i.Category).IsRequired().HasMaxLength(50);
                entity.Property(i => i.StandardUnit).IsRequired().HasMaxLength(20);
                entity.Property(i => i.Allergens)
                    .HasConversion(
                        v => string.Join(',', v),
                        v => v.Split(',', StringSplitOptions.RemoveEmptyEntries).ToList()
                    );
                entity.HasIndex(i => i.Name).IsUnique();
            });

            modelBuilder.Entity<RecipeIngredient>(entity =>
            {
                entity.HasKey(ri => ri.Id);
                entity.Property(ri => ri.Quantity).HasPrecision(10, 3);
                entity.Property(ri => ri.Unit).HasMaxLength(20);

                entity.HasOne(ri => ri.Recipe)
                    .WithMany(r => r.RecipeIngredients)
                    .HasForeignKey(ri => ri.RecipeId)
                    .OnDelete(DeleteBehavior.Cascade);

                entity.HasOne(ri => ri.Ingredient)
                    .WithMany(i => i.RecipeIngredients)
                    .HasForeignKey(ri => ri.IngredientId)
                    .OnDelete(DeleteBehavior.Cascade);
            });

            modelBuilder.Entity<WeeklyMenu>(entity =>
            {
                entity.HasKey(wm => wm.Id);
                entity.Property(wm => wm.Name).IsRequired().HasMaxLength(200);
                entity.Property(wm => wm.TotalCalories).HasPrecision(10, 2);

                entity.HasOne(wm => wm.User)
                    .WithMany(u => u.WeeklyMenus)
                    .HasForeignKey(wm => wm.UserId)
                    .OnDelete(DeleteBehavior.Cascade);
            });

            modelBuilder.Entity<MenuMeal>(entity =>
            {
                entity.HasKey(mm => mm.Id);

                entity.HasOne(mm => mm.WeeklyMenu)
                    .WithMany(wm => wm.MenuMeals)
                    .HasForeignKey(mm => mm.MenuId)
                    .OnDelete(DeleteBehavior.Cascade);

                entity.HasOne(mm => mm.Recipe)
                    .WithMany(r => r.MenuMeals)
                    .HasForeignKey(mm => mm.RecipeId)
                    .OnDelete(DeleteBehavior.Cascade);
            });

            modelBuilder.Entity<ShoppingList>(entity =>
            {
                entity.HasKey(sl => sl.Id);
                entity.Property(sl => sl.Name).IsRequired().HasMaxLength(200);

                entity.HasOne(sl => sl.WeeklyMenu)
                    .WithOne(wm => wm.ShoppingList)
                    .HasForeignKey<ShoppingList>(sl => sl.MenuId)
                    .OnDelete(DeleteBehavior.Cascade);

            });

            modelBuilder.Entity<ShoppingListItem>(entity =>
            {
                entity.HasKey(sli => sli.Id);
                entity.Property(sli => sli.Quantity).HasPrecision(10, 3);
                entity.Property(sli => sli.Unit).HasMaxLength(20);
                entity.Property(sli => sli.Category).HasMaxLength(50);

                entity.HasOne(sli => sli.ShoppingList)
                    .WithMany(sl => sl.Items)
                    .HasForeignKey(sli => sli.ShoppingListId)
                    .OnDelete(DeleteBehavior.Cascade);

                entity.HasOne(sli => sli.Ingredient)
                    .WithMany(i => i.ShoppingListItems)
                    .HasForeignKey(sli => sli.IngredientId)
                    .OnDelete(DeleteBehavior.Cascade);
            });

            modelBuilder.Entity<UserFavorite>(entity =>
            {
                entity.HasKey(uf => uf.Id);

                entity.HasOne(uf => uf.User)
                    .WithMany(u => u.Favorites)
                    .HasForeignKey(uf => uf.UserId)
                    .OnDelete(DeleteBehavior.Cascade);

                entity.HasOne(uf => uf.Recipe)
                    .WithMany(r => r.Favorites)
                    .HasForeignKey(uf => uf.RecipeId)
                    .OnDelete(DeleteBehavior.Cascade);
            });

            modelBuilder.Entity<UserInventory>(entity =>
            {
                entity.HasKey(ui => ui.Id);
                entity.Property(ui => ui.Quantity).HasPrecision(10, 3);
                entity.Property(ui => ui.Unit).HasMaxLength(20);

                entity.HasOne(ui => ui.User)
                    .WithMany(u => u.Inventory)
                    .HasForeignKey(ui => ui.UserId)
                    .OnDelete(DeleteBehavior.Cascade);

                entity.HasOne(ui => ui.Ingredient)
                    .WithMany(i => i.UserInventories)
                    .HasForeignKey(ui => ui.IngredientId)
                    .OnDelete(DeleteBehavior.Cascade);
            });

            modelBuilder.Entity<UserInventory>()
                .HasIndex(ui => new { ui.UserId, ui.IngredientId })
                .IsUnique();

            modelBuilder.Entity<UserFavorite>()
                .HasIndex(uf => new { uf.UserId, uf.RecipeId })
                .IsUnique();
        }
    }
}

namespace YP_API.Exceptions
{
    public class AppException : Exception
    {
        public int StatusCode { get; }
        public AppException(string message, int statusCode = 400) : base(message)
        {
            StatusCode = statusCode;
        }
    }

    public class NotFoundException : AppException
    {
        public NotFoundException(string message) : base(message, 404) { }
    }

    public class BadRequestException : AppException
    {
        public BadRequestException(string message) : base(message, 400) { }
    }

    public class UnauthorizedException : AppException
    {
        public UnauthorizedException(string message) : base(message, 401) { }
    }
}

namespace YP_API.Helpers
{
    public class PaginationParams
    {
        private const int MaxPageSize = 50;
        public int PageNumber { get; set; } = 1;

        private int _pageSize = 10;
        public int PageSize
        {
            get => _pageSize;
            set => _pageSize = (value > MaxPageSize) ? MaxPageSize : value;
        }
    }

    public class PagedList<T> : List<T>
    {
        public int CurrentPage { get; set; }
        public int TotalPages { get; set; }
        public int PageSize { get; set; }
        public int TotalCount { get; set; }

        public PagedList(IEnumerable<T> items, int count, int pageNumber, int pageSize)
        {
            CurrentPage = pageNumber;
            TotalPages = (int)Math.Ceiling(count / (double)pageSize);
            PageSize = pageSize;
            TotalCount = count;
            AddRange(items);
        }

        public static PagedList<T> Create(IEnumerable<T> source, int pageNumber, int pageSize)
        {
            var count = source.Count();
            var items = source.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToList();
            return new PagedList<T>(items, count, pageNumber, pageSize);
        }
    }
}

namespace YP_API.Helpers
{
    public class RecipeSearchParams : PaginationParams
    {
        public string Name { get; set; }
        public List<string> Tags { get; set; } = new List<string>();
        public List<string> ExcludedAllergens { get; set; } = new List<string>();
        public List<string> CuisineTypes { get; set; } = new List<string>();
        public int? MaxPrepTime { get; set; }
        public int? MaxCookTime { get; set; }
        public decimal? MaxCalories { get; set; }
        public string Difficulty { get; set; }
        public string SortBy { get; set; } = "name";
        public bool SortDescending { get; set; } = false;
    }

    public class IngredientSearchParams : PaginationParams
    {
        public string Category { get; set; }
        public string Name { get; set; }
        public bool? HasAllergens { get; set; }
        public string SortBy { get; set; } = "name";
        public bool SortDescending { get; set; } = false;
    }
}

using YP_API.Helpers;
using YP_API.Models;

namespace YP_API.Interfaces
{
    public interface IIngredientRepository : IRepository<Ingredient>
    {
        Task<PagedList<Ingredient>> GetIngredientsAsync(IngredientSearchParams searchParams);
        Task<IEnumerable<Ingredient>> SearchIngredientsAsync(string query);
        Task<IEnumerable<string>> GetCategoriesAsync();
        Task<Ingredient> GetIngredientByNameAsync(string name);
    }
}

using YP_API.Models;

namespace YP_API.Interfaces
{
    public interface IMenuRepository : IRepository<WeeklyMenu>
    {
        Task<WeeklyMenu> GetCurrentMenuAsync(int userId);
        Task<IEnumerable<WeeklyMenu>> GetUserMenusAsync(int userId);
        Task<WeeklyMenu> CreateMenuAsync(WeeklyMenu menu);
        Task<WeeklyMenu> GetMenuWithDetailsAsync(int menuId);
    }
}

using YP_API.Helpers;
using YP_API.Models;

namespace YP_API.Interfaces
{
    public interface IRecipeRepository : IRepository<Recipe>
    {
        Task<PagedList<Recipe>> GetRecipesAsync(RecipeSearchParams searchParams);
        Task<Recipe> GetRecipeWithDetailsAsync(int id);
        Task<IEnumerable<Recipe>> GetRecipesForMenuAsync(List<string> excludedAllergens, List<string> cuisineTags, decimal? maxCalories);
        Task<bool> ToggleFavoriteAsync(int userId, int recipeId);
        Task<bool> IsRecipeFavoriteAsync(int userId, int recipeId);
        Task<IEnumerable<Recipe>> GetUserFavoritesAsync(int userId);
        Task<IEnumerable<Recipe>> SearchRecipesAsync(string query, List<string> tags, List<string> excludedAllergens);
    }
}using Microsoft.EntityFrameworkCore;
using YP_API.Data;
using YP_API.Helpers;
using YP_API.Models;
using YP_API.Repositories;

namespace YP_API.Interfaces
{
    public interface IRepository<T> where T : class
    {
        Task<T> GetByIdAsync(int id);
        Task<IEnumerable<T>> GetAllAsync();
        Task AddAsync(T entity);
        void Update(T entity);
        void Delete(T entity);
        Task<bool> SaveAllAsync();
    }
}

using YP_API.Models;

namespace YP_API.Interfaces
{
    public interface IShoppingListRepository : IRepository<ShoppingList>
    {
        Task<ShoppingList> GetCurrentShoppingListAsync(int userId);
        Task<ShoppingList> GetShoppingListWithItemsAsync(int listId);
        Task<ShoppingListItem> GetShoppingListItemAsync(int itemId);
        Task<ShoppingList> GetShoppingListByUserIdAsync(int userId);
    }
}

using YP_API.Models;

namespace YP_API.Interfaces
{
    public interface IUserRepository : IRepository<User>
    {
        Task<User> GetUserByUsernameAsync(string username);
        Task<User> GetUserByEmailAsync(string email);
        Task<bool> UserExistsAsync(string username, string email);
    }
}

namespace YP_API.Models
{
    public class Ingredient
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Category { get; set; }
        public string StandardUnit { get; set; }
        public List<string> Allergens { get; set; } = new List<string>();

        public ICollection<RecipeIngredient> RecipeIngredients { get; set; } = new List<RecipeIngredient>();
        public ICollection<UserInventory> UserInventories { get; set; } = new List<UserInventory>();
        public ICollection<ShoppingListItem> ShoppingListItems { get; set; } = new List<ShoppingListItem>();
    }
}

namespace YP_API.Models
{
    public class MenuMeal
    {
        public int Id { get; set; }
        public int MenuId { get; set; }
        public int RecipeId { get; set; }
        public DateTime MealDate { get; set; }
        public MealType MealType { get; set; }

        public WeeklyMenu WeeklyMenu { get; set; }
        public Recipe Recipe { get; set; }
    }

    public enum MealType
    {
        Breakfast = 1,
        Lunch = 2,
        Dinner = 3,
        Snack = 4
    }
}

namespace YP_API.Models
{
    public class Recipe
    {
        public Recipe()
        {
            ImageUrl = string.Empty;
        }

        public int Id { get; set; }
        public string Title { get; set; }
        public string Description { get; set; }
        public string Instructions { get; set; }
        public int PrepTime { get; set; }
        public int CookTime { get; set; }
        public int Servings { get; set; }
        public decimal Calories { get; set; }
        public string ImageUrl { get; set; } = string.Empty;
        public List<string> Tags { get; set; } = new List<string>();
        public List<string> Allergens { get; set; } = new List<string>();
        public string CuisineType { get; set; }
        public string Difficulty { get; set; }
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public bool IsPublic { get; set; } = true;

        public ICollection<RecipeIngredient> RecipeIngredients { get; set; } = new List<RecipeIngredient>();
        public ICollection<MenuMeal> MenuMeals { get; set; } = new List<MenuMeal>();
        public ICollection<UserFavorite> Favorites { get; set; } = new List<UserFavorite>();
    }
}

namespace YP_API.Models
{
    public class RecipeIngredient
    {
        public int Id { get; set; }
        public int RecipeId { get; set; }
        public int IngredientId { get; set; }
        public decimal Quantity { get; set; }
        public string Unit { get; set; }

        public Recipe Recipe { get; set; }
        public Ingredient Ingredient { get; set; }
    }
}

namespace YP_API.Models
{
    public class ShoppingList
    {
        public int Id { get; set; }
        public int MenuId { get; set; }
        public string Name { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public bool IsCompleted { get; set; } = false;
        public int UserId { get; set; }
        public WeeklyMenu WeeklyMenu { get; set; }
        public ICollection<ShoppingListItem> Items { get; set; } = new List<ShoppingListItem>();
    }
    public class ShoppingListItem
    {
        public int Id { get; set; }
        public int ShoppingListId { get; set; }
        public int IngredientId { get; set; }
        public decimal Quantity { get; set; }
        public string Unit { get; set; }
        public bool IsPurchased { get; set; } = false;
        public string Category { get; set; }

        public ShoppingList ShoppingList { get; set; }
        public Ingredient Ingredient { get; set; }
    }
}

using System.ComponentModel.DataAnnotations.Schema;

namespace YP_API.Models
{
    public class User
    {
        public int Id { get; set; }
        public string Username { get; set; }
        public string Email { get; set; }
        public string FullName { get; set; }
        public byte[] PasswordHash { get; set; }
        public byte[] PasswordSalt { get; set; }
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public List<string> Allergies { get; set; } = new List<string>();


        public ICollection<WeeklyMenu> WeeklyMenus { get; set; } = new List<WeeklyMenu>();
        public ICollection<ShoppingList> ShoppingLists { get; set; } = new List<ShoppingList>();
        public ICollection<UserFavorite> Favorites { get; set; } = new List<UserFavorite>();
        public ICollection<UserInventory> Inventory { get; set; } = new List<UserInventory>();
    }
}

namespace YP_API.Models
{
    public class UserFavorite
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public int RecipeId { get; set; }
        public DateTime AddedAt { get; set; } = DateTime.UtcNow;

        public User User { get; set; }
        public Recipe Recipe { get; set; }
    }
}

namespace YP_API.Models
{
    public class UserInventory
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public int IngredientId { get; set; }
        public decimal Quantity { get; set; }
        public string Unit { get; set; }
        public DateTime? ExpiryDate { get; set; }
        public DateTime AddedAt { get; set; } = DateTime.UtcNow;

        public User User { get; set; }
        public Ingredient Ingredient { get; set; }
    }
}

namespace YP_API.Models
{
    public class WeeklyMenu
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public string Name { get; set; }
        public DateTime StartDate { get; set; }
        public DateTime EndDate { get; set; }
        public decimal TotalCalories { get; set; }
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        public User User { get; set; }
        public ShoppingList ShoppingList { get; set; }
        public ICollection<MenuMeal> MenuMeals { get; set; } = new List<MenuMeal>();
    }
}

п»їnamespace YP_API.Models.Dtos
{
    using System.Collections.Generic;

    public class UpdateAllergiesDto
    {
        /// <summary>
        /// РЎРїРёСЃРѕРє РІС‹Р±СЂР°РЅРЅС‹С… Р°Р»Р»РµСЂРіРµРЅРѕРІ.
        /// </summary>
        public List<string> Allergies { get; set; } = new List<string>();
    }
}п»їnamespace YP_API.Models.Dtos
{
    public class UserAuthResponse
    {
        public int Id { get; set; }
        public string Username { get; set; }
        public string Email { get; set; }
        public string FullName { get; set; }
        public string Token { get; set; }
    }
}// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
//------------------------------------------------------------------------------
// <auto-generated>
//     Р­С‚РѕС‚ РєРѕРґ СЃРѕР·РґР°РЅ РїСЂРѕРіСЂР°РјРјРѕР№.
//     РСЃРїРѕР»РЅСЏРµРјР°СЏ РІРµСЂСЃРёСЏ:4.0.30319.42000
//
//     РР·РјРµРЅРµРЅРёСЏ РІ СЌС‚РѕРј С„Р°Р№Р»Рµ РјРѕРіСѓС‚ РїСЂРёРІРµСЃС‚Рё Рє РЅРµРїСЂР°РІРёР»СЊРЅРѕР№ СЂР°Р±РѕС‚Рµ Рё Р±СѓРґСѓС‚ РїРѕС‚РµСЂСЏРЅС‹ РІ СЃР»СѓС‡Р°Рµ
//     РїРѕРІС‚РѕСЂРЅРѕР№ РіРµРЅРµСЂР°С†РёРё РєРѕРґР°.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("YP_API")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+f5bbce9ff5ec939e212a4c95803642f24d9a35a3")]
[assembly: System.Reflection.AssemblyProductAttribute("YP_API")]
[assembly: System.Reflection.AssemblyTitleAttribute("YP_API")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// РЎРѕР·РґР°РЅРѕ РєР»Р°СЃСЃРѕРј WriteCodeFragment MSBuild.

// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;
//------------------------------------------------------------------------------
// <auto-generated>
//     Р­С‚РѕС‚ РєРѕРґ СЃРѕР·РґР°РЅ РїСЂРѕРіСЂР°РјРјРѕР№.
//     РСЃРїРѕР»РЅСЏРµРјР°СЏ РІРµСЂСЃРёСЏ:4.0.30319.42000
//
//     РР·РјРµРЅРµРЅРёСЏ РІ СЌС‚РѕРј С„Р°Р№Р»Рµ РјРѕРіСѓС‚ РїСЂРёРІРµСЃС‚Рё Рє РЅРµРїСЂР°РІРёР»СЊРЅРѕР№ СЂР°Р±РѕС‚Рµ Рё Р±СѓРґСѓС‚ РїРѕС‚РµСЂСЏРЅС‹ РІ СЃР»СѓС‡Р°Рµ
//     РїРѕРІС‚РѕСЂРЅРѕР№ РіРµРЅРµСЂР°С†РёРё РєРѕРґР°.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Swashbuckle.AspNetCore.SwaggerGen")]

// РЎРѕР·РґР°РЅРѕ РєР»Р°СЃСЃРѕРј WriteCodeFragment MSBuild.

//------------------------------------------------------------------------------
// <auto-generated>
//     Р­С‚РѕС‚ РєРѕРґ СЃРѕР·РґР°РЅ РїСЂРѕРіСЂР°РјРјРѕР№.
//     РСЃРїРѕР»РЅСЏРµРјР°СЏ РІРµСЂСЃРёСЏ:4.0.30319.42000
//
//     РР·РјРµРЅРµРЅРёСЏ РІ СЌС‚РѕРј С„Р°Р№Р»Рµ РјРѕРіСѓС‚ РїСЂРёРІРµСЃС‚Рё Рє РЅРµРїСЂР°РІРёР»СЊРЅРѕР№ СЂР°Р±РѕС‚Рµ Рё Р±СѓРґСѓС‚ РїРѕС‚РµСЂСЏРЅС‹ РІ СЃР»СѓС‡Р°Рµ
//     РїРѕРІС‚РѕСЂРЅРѕР№ РіРµРЅРµСЂР°С†РёРё РєРѕРґР°.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ProvideApplicationPartFactoryAttribute("Microsoft.AspNetCore.Mvc.ApplicationParts.ConsolidatedAssemblyApplicationPartFact" +
    "ory, Microsoft.AspNetCore.Mvc.Razor")]

// РЎРѕР·РґР°РЅРѕ РєР»Р°СЃСЃРѕРј WriteCodeFragment MSBuild.

using System.Diagnostics;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace YP_API.Pages
{
    [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
    [IgnoreAntiforgeryToken]
    public class ErrorModel : PageModel
    {
        public string? RequestId { get; set; }

        public bool ShowRequestId => !string.IsNullOrEmpty(RequestId);

        private readonly ILogger<ErrorModel> _logger;

        public ErrorModel(ILogger<ErrorModel> logger)
        {
            _logger = logger;
        }

        public void OnGet()
        {
            RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier;
        }
    }

}

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace YP_API.Pages
{
    public class IndexModel : PageModel
    {
        private readonly ILogger<IndexModel> _logger;

        public IndexModel(ILogger<IndexModel> logger)
        {
            _logger = logger;
        }

        public void OnGet()
        {

        }
    }
}

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace YP_API.Pages
{
    public class PrivacyModel : PageModel
    {
        private readonly ILogger<PrivacyModel> _logger;

        public PrivacyModel(ILogger<PrivacyModel> logger)
        {
            _logger = logger;
        }

        public void OnGet()
        {
        }
    }

}

using Microsoft.EntityFrameworkCore;
using YP_API.Data;
using YP_API.Helpers;
using YP_API.Interfaces;
using YP_API.Models;

namespace YP_API.Repositories
{
    public class IngredientRepository : Repository<Ingredient>, IIngredientRepository
    {
        public IngredientRepository(RecipePlannerContext context) : base(context) { }

        public async Task<PagedList<Ingredient>> GetIngredientsAsync(IngredientSearchParams searchParams)
        {
            var query = _context.Ingredients.AsQueryable();

            if (!string.IsNullOrEmpty(searchParams.Name))
                query = query.Where(i => i.Name.Contains(searchParams.Name));

            if (!string.IsNullOrEmpty(searchParams.Category))
                query = query.Where(i => i.Category == searchParams.Category);

            if (searchParams.HasAllergens.HasValue)
                query = searchParams.HasAllergens.Value
                    ? query.Where(i => i.Allergens.Any())
                    : query.Where(i => !i.Allergens.Any());

            query = searchParams.SortBy?.ToLower() switch
            {
                "category" => searchParams.SortDescending
                    ? query.OrderByDescending(i => i.Category)
                    : query.OrderBy(i => i.Category),
                _ => searchParams.SortDescending
                    ? query.OrderByDescending(i => i.Name)
                    : query.OrderBy(i => i.Name)
            };

            var totalCount = await query.CountAsync();
            var items = await query
                .Skip((searchParams.PageNumber - 1) * searchParams.PageSize)
                .Take(searchParams.PageSize)
                .ToListAsync();

            return new PagedList<Ingredient>(items, totalCount, searchParams.PageNumber, searchParams.PageSize);
        }

        public async Task<IEnumerable<Ingredient>> SearchIngredientsAsync(string query)
        {
            return await _context.Ingredients
                .Where(i => i.Name.Contains(query))
                .OrderBy(i => i.Name)
                .Take(20)
                .ToListAsync();
        }

        public async Task<IEnumerable<string>> GetCategoriesAsync()
        {
            return await _context.Ingredients
                .Select(i => i.Category)
                .Distinct()
                .OrderBy(c => c)
                .ToListAsync();
        }

        public async Task<Ingredient> GetIngredientByNameAsync(string name)
        {
            return await _context.Ingredients
                .FirstOrDefaultAsync(i => i.Name == name);
        }
    }
}

using Microsoft.EntityFrameworkCore;
using YP_API.Data;
using YP_API.Interfaces;
using YP_API.Models;

namespace YP_API.Repositories
{
    public class MenuRepository : Repository<WeeklyMenu>, IMenuRepository
    {
        public MenuRepository(RecipePlannerContext context) : base(context) { }

        public async Task<WeeklyMenu> GetCurrentMenuAsync(int userId)
        {
            var today = DateTime.Today;
            return await _context.WeeklyMenus
                .Include(wm => wm.MenuMeals)
                    .ThenInclude(mm => mm.Recipe)
                .Where(wm => wm.UserId == userId && wm.StartDate <= today && wm.EndDate >= today)
                .OrderByDescending(wm => wm.CreatedAt)
                .FirstOrDefaultAsync();
        }

        public async Task<IEnumerable<WeeklyMenu>> GetUserMenusAsync(int userId)
        {
            return await _context.WeeklyMenus
                .Include(wm => wm.MenuMeals)
                    .ThenInclude(mm => mm.Recipe)
                .Where(wm => wm.UserId == userId)
                .OrderByDescending(wm => wm.CreatedAt)
                .Take(10)
                .ToListAsync();
        }

        public async Task<WeeklyMenu> CreateMenuAsync(WeeklyMenu menu)
        {
            await _context.WeeklyMenus.AddAsync(menu);
            return menu;
        }

        public async Task<WeeklyMenu> GetMenuWithDetailsAsync(int menuId)
        {
            return await _context.WeeklyMenus
                .Include(wm => wm.MenuMeals)
                    .ThenInclude(mm => mm.Recipe)
                        .ThenInclude(r => r.RecipeIngredients)
                            .ThenInclude(ri => ri.Ingredient)
                .FirstOrDefaultAsync(wm => wm.Id == menuId);
        }
    }
}

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using YP_API.Data;
using YP_API.Helpers;
using YP_API.Interfaces;
using YP_API.Models;

namespace YP_API.Repositories
{
    public class RecipeRepository : Repository<Recipe>, IRecipeRepository
    {
        private readonly ILogger<RecipeRepository> _logger;

        public RecipeRepository(RecipePlannerContext context, ILogger<RecipeRepository> logger) : base(context)
        {
            _logger = logger;
        }

        public async Task<bool> ToggleFavoriteAsync(int userId, int recipeId)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();

            try
            {
                _logger.LogInformation($"ToggleFavoriteAsync: UserId={userId}, RecipeId={recipeId}");

                var recipe = await _context.Recipes.FindAsync(recipeId);
                if (recipe == null)
                {
                    _logger.LogWarning($"Recipe {recipeId} not found");
                    throw new Exception($"Рецепт с ID {recipeId} не найден");
                }

                var user = await _context.Users.FindAsync(userId);
                if (user == null)
                {
                    _logger.LogWarning($"User {userId} not found");
                    throw new Exception($"Пользователь с ID {userId} не найден");
                }

                var existingFavorite = await _context.UserFavorites
                    .AsNoTracking()
                    .FirstOrDefaultAsync(uf => uf.UserId == userId && uf.RecipeId == recipeId);

                if (existingFavorite != null)
                {
                    _logger.LogInformation($"Removing recipe {recipeId} from favorites for user {userId}");
                    _context.UserFavorites.Remove(existingFavorite);
                }
                else
                {
                    _logger.LogInformation($"Adding recipe {recipeId} to favorites for user {userId}");
                    var favorite = new UserFavorite
                    {
                        UserId = userId,
                        RecipeId = recipeId,
                        AddedAt = DateTime.UtcNow
                    };
                    await _context.UserFavorites.AddAsync(favorite);
                }

                var result = await _context.SaveChangesAsync() > 0;

                if (result)
                {
                    await transaction.CommitAsync();
                    _logger.LogInformation($"Favorite toggled successfully for user {userId}, recipe {recipeId}");
                }
                else
                {
                    await transaction.RollbackAsync();
                    _logger.LogWarning($"Failed to save favorite changes for user {userId}, recipe {recipeId}");
                }

                return result;
            }
            catch (DbUpdateException dbEx)
            {
                await transaction.RollbackAsync();
                _logger.LogError($"Database error in ToggleFavoriteAsync: {dbEx.Message}");
                _logger.LogError($"Inner exception: {dbEx.InnerException?.Message}");

                if (dbEx.InnerException?.Message?.Contains("foreign key constraint") == true)
                {
                    throw new Exception("Ошибка связи с базой данных. Проверьте существование рецепта и пользователя.");
                }

                throw new Exception("Ошибка базы данных при изменении избранного");
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync();
                _logger.LogError($"Error in ToggleFavoriteAsync: {ex.Message}");
                _logger.LogError($"Inner exception: {ex.InnerException?.Message}");
                throw new Exception($"Ошибка при изменении избранного: {ex.Message}");
            }
        }

        public async Task<bool> IsRecipeFavoriteAsync(int userId, int recipeId)
        {
            return await _context.UserFavorites
                .AnyAsync(uf => uf.UserId == userId && uf.RecipeId == recipeId);
        }

        public async Task<PagedList<Recipe>> GetRecipesAsync(RecipeSearchParams searchParams)
        {
            var query = _context.Recipes
                .Include(r => r.RecipeIngredients)
                    .ThenInclude(ri => ri.Ingredient)
                .AsQueryable();

            if (!string.IsNullOrEmpty(searchParams.Name))
                query = query.Where(r => r.Title.Contains(searchParams.Name));

            if (searchParams.Tags.Any())
            {
                var allRecipes = await query.ToListAsync();
                var filteredRecipes = allRecipes.Where(r => searchParams.Tags.All(t => r.Tags.Contains(t))).ToList();

                return PagedList<Recipe>.Create(
                    filteredRecipes,
                    searchParams.PageNumber,
                    searchParams.PageSize
                );
            }

            if (searchParams.ExcludedAllergens.Any())
            {
                var allRecipes = await query.ToListAsync();
                var filteredRecipes = allRecipes.Where(r => !r.Allergens.Any(a => searchParams.ExcludedAllergens.Contains(a))).ToList();

                return PagedList<Recipe>.Create(
                    filteredRecipes,
                    searchParams.PageNumber,
                    searchParams.PageSize
                );
            }

            if (searchParams.MaxPrepTime.HasValue)
                query = query.Where(r => r.PrepTime <= searchParams.MaxPrepTime.Value);

            if (searchParams.MaxCalories.HasValue)
                query = query.Where(r => r.Calories <= searchParams.MaxCalories.Value);

            if (searchParams.CuisineTypes.Any())
            {
                var allRecipes = await query.ToListAsync();
                var filteredRecipes = allRecipes.Where(r => searchParams.CuisineTypes.Contains(r.CuisineType)).ToList();

                return PagedList<Recipe>.Create(
                    filteredRecipes,
                    searchParams.PageNumber,
                    searchParams.PageSize
                );
            }

            query = searchParams.SortBy?.ToLower() switch
            {
                "calories" => searchParams.SortDescending
                    ? query.OrderByDescending(r => r.Calories)
                    : query.OrderBy(r => r.Calories),
                "time" => searchParams.SortDescending
                    ? query.OrderByDescending(r => r.PrepTime + r.CookTime)
                    : query.OrderBy(r => r.PrepTime + r.CookTime),
                "difficulty" => searchParams.SortDescending
                    ? query.OrderByDescending(r => r.Difficulty)
                    : query.OrderBy(r => r.Difficulty),
                _ => searchParams.SortDescending
                    ? query.OrderByDescending(r => r.Title)
                    : query.OrderBy(r => r.Title)
            };

            var totalCount = await query.CountAsync();
            var recipes = await query
                .Skip((searchParams.PageNumber - 1) * searchParams.PageSize)
                .Take(searchParams.PageSize)
                .ToListAsync();

            return new PagedList<Recipe>(recipes, totalCount, searchParams.PageNumber, searchParams.PageSize);
        }

        public async Task<Recipe> GetRecipeWithDetailsAsync(int id)
        {
            return await _context.Recipes
                .Include(r => r.RecipeIngredients)
                    .ThenInclude(ri => ri.Ingredient)
                .FirstOrDefaultAsync(r => r.Id == id);
        }

        public async Task<IEnumerable<Recipe>> GetRecipesForMenuAsync(List<string> excludedAllergens, List<string> cuisineTags, decimal? maxCalories)
        {
            var recipes = await _context.Recipes
                .Include(r => r.RecipeIngredients)
                    .ThenInclude(ri => ri.Ingredient)
                .Where(r => r.IsPublic)
                .ToListAsync();

            if (excludedAllergens != null && excludedAllergens.Any())
            {
                recipes = recipes.Where(r => !r.Allergens.Any(a => excludedAllergens.Contains(a))).ToList();
            }

            if (cuisineTags != null && cuisineTags.Any())
            {
                recipes = recipes.Where(r => cuisineTags.Contains(r.CuisineType)).ToList();
            }

            if (maxCalories.HasValue)
            {
                recipes = recipes.Where(r => r.Calories <= maxCalories.Value).ToList();
            }

            return recipes;
        }

        public async Task<IEnumerable<Recipe>> GetUserFavoritesAsync(int userId)
        {
            return await _context.UserFavorites
                .Where(uf => uf.UserId == userId)
                .Include(uf => uf.Recipe)
                    .ThenInclude(r => r.RecipeIngredients)
                        .ThenInclude(ri => ri.Ingredient)
                .Select(uf => uf.Recipe)
                .ToListAsync();
        }

        public async Task<IEnumerable<Recipe>> SearchRecipesAsync(string query, List<string> tags, List<string> excludedAllergens)
        {
            var searchQuery = _context.Recipes
                .Include(r => r.RecipeIngredients)
                    .ThenInclude(ri => ri.Ingredient)
                .AsQueryable();

            if (!string.IsNullOrEmpty(query))
            {
                searchQuery = searchQuery.Where(r =>
                    r.Title.Contains(query) ||
                    r.Description.Contains(query) ||
                    r.Tags.Any(t => t.Contains(query)) ||
                    r.RecipeIngredients.Any(ri => ri.Ingredient.Name.Contains(query))
                );
            }

            if (tags != null && tags.Any())
                searchQuery = searchQuery.Where(r => tags.All(t => r.Tags.Contains(t)));

            if (excludedAllergens != null && excludedAllergens.Any())
                searchQuery = searchQuery.Where(r => !r.Allergens.Any(a => excludedAllergens.Contains(a)));

            return await searchQuery.Take(50).ToListAsync();
        }
    }
}using Microsoft.EntityFrameworkCore;
using YP_API.Data;
using YP_API.Interfaces;

namespace YP_API.Repositories
{
    public class Repository<T> : IRepository<T> where T : class
    {
        protected readonly RecipePlannerContext _context;

        public Repository(RecipePlannerContext context)
        {
            _context = context;
        }

        public virtual async Task<T> GetByIdAsync(int id)
        {
            return await _context.Set<T>().FindAsync(id);
        }

        public virtual async Task<IEnumerable<T>> GetAllAsync()
        {
            return await _context.Set<T>().ToListAsync();
        }

        public virtual async Task AddAsync(T entity)
        {
            await _context.Set<T>().AddAsync(entity);
        }

        public virtual void Update(T entity)
        {
            _context.Set<T>().Update(entity);
        }

        public virtual void Delete(T entity)
        {
            _context.Set<T>().Remove(entity);
        }

        public virtual async Task<bool> SaveAllAsync()
        {
            return await _context.SaveChangesAsync() > 0;
        }
    }
}

using Microsoft.EntityFrameworkCore;
using YP_API.Data;
using YP_API.Interfaces;
using YP_API.Models;

namespace YP_API.Repositories
{
    public class ShoppingListRepository : Repository<ShoppingList>, IShoppingListRepository
    {
        public ShoppingListRepository(RecipePlannerContext context) : base(context) { }

        public async Task<ShoppingList> GetCurrentShoppingListAsync(int userId)
        {
            return await _context.ShoppingLists
                .Include(sl => sl.Items)
                    .ThenInclude(sli => sli.Ingredient)
                .Where(sl => sl.UserId == userId && !sl.IsCompleted)
                .OrderByDescending(sl => sl.CreatedAt)
                .FirstOrDefaultAsync();
        }

        public async Task<ShoppingList> GetShoppingListWithItemsAsync(int listId)
        {
            return await _context.ShoppingLists
                .Include(sl => sl.Items)
                    .ThenInclude(sli => sli.Ingredient)
                .FirstOrDefaultAsync(sl => sl.Id == listId);
        }

        public async Task<ShoppingListItem> GetShoppingListItemAsync(int itemId)
        {
            return await _context.ShoppingListItems
                .Include(sli => sli.ShoppingList)
                .FirstOrDefaultAsync(sli => sli.Id == itemId);
        }

        public async Task<ShoppingList> GetShoppingListByUserIdAsync(int userId)
        {
            try
            {
                return await _context.ShoppingLists
                    .Include(sl => sl.WeeklyMenu)
                    .Include(sl => sl.Items)
                        .ThenInclude(sli => sli.Ingredient)
                    .Where(sl => sl.WeeklyMenu != null && sl.WeeklyMenu.UserId == userId)
                    .OrderByDescending(sl => sl.CreatedAt)
                    .FirstOrDefaultAsync();
            }
            catch (Exception ex)
            {
                
                Console.WriteLine($"Error in GetShoppingListByUserIdAsync: {ex.Message}");
                return null;
            }
        }
    }
}

using Microsoft.EntityFrameworkCore;
using YP_API.Data;
using YP_API.Interfaces;
using YP_API.Models;

namespace YP_API.Repositories
{
    public class UserRepository : Repository<User>, IUserRepository
    {
        public UserRepository(RecipePlannerContext context) : base(context) { }

        public async Task<User> GetUserByUsernameAsync(string username)
        {
            return await _context.Users
                .FirstOrDefaultAsync(u => u.Username == username);
        }

        public async Task<User> GetUserByEmailAsync(string email)
        {
            return await _context.Users
                .FirstOrDefaultAsync(u => u.Email == email);
        }

        public async Task<bool> UserExistsAsync(string username, string email)
        {
            return await _context.Users
                .AnyAsync(u => u.Username == username || u.Email == email);
        }
    }
}

using System.Security.Cryptography;
using System.Text;
using YP_API.Interfaces;
using YP_API.Models;

namespace YP_API.Services
{
    public class AuthService : IAuthService
    {
        private readonly IUserRepository _userRepository;

        public AuthService(IUserRepository userRepository)
        {
            _userRepository = userRepository;
        }

        public async Task<User> Register(string username, string email, string fullName, string password, List<string> allergies)
        {
            if (await _userRepository.UserExistsAsync(username, email))
                throw new Exception("Username or email already exists");

            using var hmac = new HMACSHA512();

            var user = new User
            {
                Username = username.ToLower().Trim(),
                Email = email.ToLower().Trim(),
                FullName = fullName?.Trim() ?? "",
                Allergies = allergies ?? new List<string>(),
                PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(password)),
                PasswordSalt = hmac.Key,
                CreatedAt = DateTime.UtcNow
            };

            await _userRepository.AddAsync(user);

            if (!await _userRepository.SaveAllAsync())
                throw new Exception("Failed to save user");

            return user;
        }

        public async Task<User> Login(string username, string password)
        {
            var user = await _userRepository.GetUserByUsernameAsync(username.ToLower());

            if (user == null)
                throw new Exception("Invalid username");

            using var hmac = new HMACSHA512(user.PasswordSalt);
            var computedHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(password));

            for (int i = 0; i < computedHash.Length; i++)
            {
                if (computedHash[i] != user.PasswordHash[i])
                    throw new Exception("Invalid password");
            }

            return user;
        }
    }

    public interface IAuthService
    {
        Task<User> Register(string username, string email, string fullName, string password, List<string> allergies);
        Task<User> Login(string username, string password);
    }
}using YP_API.Interfaces;
using YP_API.Models;
using YP_API.Repositories;

namespace YP_API.Services
{
    public class MenuService : IMenuService
    {
        private readonly IMenuRepository _menuRepository;
        private readonly IRecipeRepository _recipeRepository;
        private readonly ILogger<MenuService> _logger;

        public MenuService(IMenuRepository menuRepository, IRecipeRepository recipeRepository, ILogger<MenuService> logger)
        {
            _menuRepository = menuRepository;
            _recipeRepository = recipeRepository;
            _logger = logger;
        }

        public async Task<WeeklyMenu> GenerateWeeklyMenuAsync(int userId, Controllers.GenerateMenuRequest request, List<string> userAllergies)
        {
            _logger.LogInformation($"Generating menu for user {userId}, days: {request.Days}");

            var availableRecipes = (await _recipeRepository.GetRecipesForMenuAsync(
                userAllergies ?? new List<string>(),
                request.CuisineTags ?? new List<string>(),
                request.TargetCaloriesPerDay)).ToList();

            _logger.LogInformation($"Found {availableRecipes.Count} available recipes");

            if (!availableRecipes.Any())
            {
                throw new Exception("No recipes available for menu generation with current filters");
            }

            var menu = new WeeklyMenu
            {
                UserId = userId,
                Name = $"Меню на {request.Days} дней",
                StartDate = DateTime.Today,
                EndDate = DateTime.Today.AddDays(request.Days - 1),
                CreatedAt = DateTime.UtcNow
            };

            var random = new Random();
            var totalCalories = 0m;
            var usedRecipeIds = new HashSet<int>();

            for (int i = 0; i < request.Days; i++)
            {
                var date = DateTime.Today.AddDays(i);

                foreach (var mealType in request.MealTypes ?? new List<string> { "breakfast", "lunch", "dinner" })
                {
                    var suitableRecipes = availableRecipes
                        .Where(r => !usedRecipeIds.Contains(r.Id))
                        .Where(r => r.Tags.Contains(mealType) || IsSuitableForMealType(r, mealType))
                        .ToList();

                    if (suitableRecipes.Any())
                    {
                        var selectedRecipe = suitableRecipes[random.Next(suitableRecipes.Count)];
                        usedRecipeIds.Add(selectedRecipe.Id);

                        menu.MenuMeals.Add(new MenuMeal
                        {
                            MealDate = date,
                            MealType = Enum.Parse<MealType>(mealType, true),
                            RecipeId = selectedRecipe.Id
                        });

                        totalCalories += selectedRecipe.Calories;
                        _logger.LogInformation($"Added {mealType}: {selectedRecipe.Title} ({selectedRecipe.Calories} cal)");
                    }
                    else
                    {
                        _logger.LogWarning($"No suitable recipes found for {mealType} on {date.ToShortDateString()}");
                    }
                }
            }

            menu.TotalCalories = totalCalories;

            var createdMenu = await _menuRepository.CreateMenuAsync(menu);
            await _menuRepository.SaveAllAsync();

            _logger.LogInformation($"Menu created successfully with ID: {createdMenu.Id}, {menu.MenuMeals.Count} meals, {totalCalories} total calories");

            return await GetMenuWithDetailsAsync(createdMenu.Id);
        }

        public async Task<WeeklyMenu> GetCurrentMenuAsync(int userId)
        {
            return await _menuRepository.GetCurrentMenuAsync(userId);
        }

        public async Task<List<WeeklyMenu>> GetUserMenuHistoryAsync(int userId)
        {
            var menus = await _menuRepository.GetUserMenusAsync(userId);
            return menus.ToList();
        }

        public async Task<WeeklyMenu> RegenerateDayAsync(int menuId, DateTime date, List<string> userAllergies)
        {
            return await _menuRepository.GetMenuWithDetailsAsync(menuId);
        }

        private async Task<WeeklyMenu> GetMenuWithDetailsAsync(int menuId)
        {
            return await _menuRepository.GetMenuWithDetailsAsync(menuId);
        }

        private bool IsSuitableForMealType(Recipe recipe, string mealType)
        {
            if (recipe.Tags == null || !recipe.Tags.Any())
                return false;

            return mealType.ToLower() switch
            {
                "breakfast" => recipe.Tags.Any(t => t.Contains("breakfast") || t.Contains("morning") || t.Contains("завтрак")),
                "lunch" => recipe.Tags.Any(t => t.Contains("lunch") || t.Contains("main") || t.Contains("обед")),
                "dinner" => recipe.Tags.Any(t => t.Contains("dinner") || t.Contains("main") || t.Contains("ужин")),
                "snack" => recipe.Tags.Any(t => t.Contains("snack") || t.Contains("quick") || t.Contains("перекус")),
                _ => false
            };
        }
    }

    public interface IMenuService
    {
        Task<WeeklyMenu> GenerateWeeklyMenuAsync(int userId, Controllers.GenerateMenuRequest request, List<string> userAllergies);
        Task<WeeklyMenu> GetCurrentMenuAsync(int userId);
        Task<List<WeeklyMenu>> GetUserMenuHistoryAsync(int userId);
        Task<WeeklyMenu> RegenerateDayAsync(int menuId, DateTime date, List<string> userAllergies);
    }
}using Microsoft.EntityFrameworkCore;
using YP_API.Interfaces;
using YP_API.Models;
using YP_API.Repositories;

namespace YP_API.Services
{
    public class ShoppingListService : IShoppingListService
    {
        private readonly IShoppingListRepository _shoppingListRepository;
        private readonly IMenuRepository _menuRepository;
        private readonly IIngredientRepository _ingredientRepository;
        private readonly IRepository<ShoppingList> _shoppingListRepo;
        private readonly IRepository<ShoppingListItem> _shoppingListItemRepo;

        public ShoppingListService(
            IShoppingListRepository shoppingListRepository,
            IMenuRepository menuRepository,
            IIngredientRepository ingredientRepository,
            IRepository<ShoppingList> shoppingListRepo,
            IRepository<ShoppingListItem> shoppingListItemRepo)
        {
            _shoppingListRepository = shoppingListRepository;
            _menuRepository = menuRepository;
            _ingredientRepository = ingredientRepository;
            _shoppingListRepo = shoppingListRepo;
            _shoppingListItemRepo = shoppingListItemRepo;
        }

        public async Task<ShoppingList> GenerateShoppingListFromMenuAsync(int menuId, int userId)
        {
            try
            {
                Console.WriteLine($"=== START GenerateShoppingListFromMenuAsync ===");
                Console.WriteLine($"MenuId: {menuId}, UserId: {userId}");

                var menu = await _menuRepository.GetByIdAsync(menuId);
                if (menu == null)
                {
                    throw new Exception($"Меню с ID {menuId} не найдено");
                }

                // Проверяем, что меню принадлежит пользователю
                if (menu.UserId != userId)
                {
                    throw new Exception("Меню не принадлежит пользователю");
                }

                // Получаем меню с деталями (рецептами и ингредиентами)
                var menuWithDetails = await _menuRepository.GetMenuWithDetailsAsync(menuId);
                if (menuWithDetails == null)
                {
                    throw new Exception("Не удалось загрузить детали меню");
                }

                Console.WriteLine($"Menu has {menuWithDetails.MenuMeals?.Count} meals");

                // Создаем список покупок
                var shoppingList = new ShoppingList
                {
                    MenuId = menuId,
                    UserId = userId,
                    Name = $"Список покупок для {menu.Name}",
                    CreatedAt = DateTime.UtcNow,
                    IsCompleted = false,
                    Items = new List<ShoppingListItem>() // Инициализируем коллекцию
                };

                // Собираем все ингредиенты из всех рецептов меню
                var ingredientQuantities = new Dictionary<int, (decimal Quantity, string Unit, string Category)>();

                foreach (var menuMeal in menuWithDetails.MenuMeals ?? new List<MenuMeal>())
                {
                    var recipe = menuMeal.Recipe;
                    if (recipe?.RecipeIngredients == null) continue;

                    foreach (var recipeIngredient in recipe.RecipeIngredients)
                    {
                        var ingredient = recipeIngredient.Ingredient;
                        if (ingredient == null) continue;

                        if (ingredientQuantities.ContainsKey(ingredient.Id))
                        {
                            // Суммируем количество если ингредиент уже есть
                            var existing = ingredientQuantities[ingredient.Id];
                            ingredientQuantities[ingredient.Id] = (
                                existing.Quantity + recipeIngredient.Quantity,
                                existing.Unit,
                                existing.Category
                            );
                        }
                        else
                        {
                            // Добавляем новый ингредиент
                            ingredientQuantities[ingredient.Id] = (
                                recipeIngredient.Quantity,
                                recipeIngredient.Unit,
                                ingredient.Category
                            );
                        }
                    }
                }

                // Создаем элементы списка покупок
                foreach (var (ingredientId, (quantity, unit, category)) in ingredientQuantities)
                {
                    shoppingList.Items.Add(new ShoppingListItem
                    {
                        IngredientId = ingredientId,
                        Quantity = quantity,
                        Unit = unit,
                        Category = category,
                        IsPurchased = false
                    });
                }

                Console.WriteLine($"Created shopping list with {shoppingList.Items.Count} items");

                // Сохраняем список покупок (включая элементы)
                await _shoppingListRepository.AddAsync(shoppingList);
                Console.WriteLine("ShoppingList added to repository");

                var saveResult = await _shoppingListRepository.SaveAllAsync();
                Console.WriteLine($"Save result: {saveResult}");

                if (!saveResult)
                {
                    throw new Exception("Не удалось сохранить список покупок");
                }

                Console.WriteLine($"ShoppingList saved with ID: {shoppingList.Id}");
                Console.WriteLine("=== SUCCESS ===");

                return shoppingList;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"=== ERROR ===");
                Console.WriteLine($"Message: {ex.Message}");
                Console.WriteLine($"Inner Exception: {ex.InnerException?.Message}");
                throw new Exception($"Ошибка при создании списка покупок: {ex.Message}");
            }
        }
        public async Task<ShoppingList> GetCurrentShoppingListAsync(int userId)
        {
            var shoppingList = await _shoppingListRepository.GetShoppingListByUserIdAsync(userId);
            return shoppingList;
        }

        public async Task<bool> ToggleItemPurchasedAsync(int itemId, bool isPurchased)
        {
            var item = await _shoppingListRepository.GetShoppingListItemAsync(itemId);
            if (item == null) return false;

            item.IsPurchased = isPurchased;
            _shoppingListRepository.Update(item.ShoppingList);
            return await _shoppingListRepository.SaveAllAsync();
        }
    }
    public interface IShoppingListService
    {
        Task<ShoppingList> GenerateShoppingListFromMenuAsync(int menuId, int userId);
        Task<ShoppingList> GetCurrentShoppingListAsync(int userId);
        Task<bool> ToggleItemPurchasedAsync(int itemId, bool isPurchased);
    }
}

